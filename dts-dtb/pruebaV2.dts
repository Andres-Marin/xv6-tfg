/dts-v1/;

/memreserve/	0x0000000000000000 0x0000000000001000;
/ {
	compatible = "raspberrypi,4-model-b\0brcm,bcm2711";
	model = "Raspberry Pi 4 Model B";
	#address-cells = <0x02>;
	#size-cells = <0x01>;
	interrupt-parent = <0x01>;

	aliases {
		// serial0 = "/soc/serial@7e215040";
		// serial1 = "/soc/serial@7e201000";
		soc = "/soc";
		uart_clock = "/soc/clocks/uartclk";
		uart0 = "/soc/serial@7e201000";
		uart1 = "/soc/serial@7e215000";
		uart1_regmap = "/soc/serial@7e215000/uart1-regmap";
		aux_enables = "/soc/serial@7e215000/uart1-regmap/aux-enables@04";
		aux_mu_io = "/soc/serial@7e215000/uart1-regmap/reg-aux-mu-io@40";
		aux_mu_ier = "/soc/serial@7e215000/uart1-regmap/reg-aux-mu-ier@44";
		aux_mu_iir = "/soc/serial@7e215000/uart1-regmap/reg-aux-mu-iir@48";
		aux_mu_lcr = "/soc/serial@7e215000/uart1-regmap/reg-aux-mu-lcr@4C";
		aux_mu_mcr = "/soc/serial@7e215000/uart1-regmap/reg-aux-mu-mcr@50";
		aux_mu_lsr = "/soc/serial@7e215000/uart1-regmap/reg-aux-mu-lsr@54";
		aux_mu_msr = "/soc/serial@7e215000/uart1-regmap/reg-aux-mu-msr@58";
		aux_mu_scratch = "/soc/serial@7e215000/uart1-regmap/reg-aux-mu-scratch@5C";
		aux_mu_cntl = "/soc/serial@7e215000/uart1-regmap/reg-aux-mu-cntl@60";
		aux_mu_stat = "/soc/serial@7e215000/uart1-regmap/reg-aux-mu-stat@64";
		aux_mu_baud = "/soc/serial@7e215000/uart1-regmap/reg-aux-mu-baud@68";
	};

	chosen {
		bootargs = "coherent_pool=1M 8250.nr_uarts=1";
	};

	reserved-memory {
		#address-cells = <0x02>;
		#size-cells = <0x01>;
		ranges;
		phandle = <0x41>;

		linux,cma {
			compatible = "shared-dma-pool";
			size = <0x4000000>;
			reusable;
			linux,cma-default;
			alloc-ranges = <0x00 0x00 0x30000000>;
			phandle = <0x42>;
		};

		nvram@0 {
			compatible = "raspberrypi,bootloader-config\0nvmem-rmem";
			#address-cells = <0x01>;
			#size-cells = <0x01>;
			reg = <0x00 0x00 0x00>;
			no-map;
			status = "disabled";
			phandle = <0x43>;
		};
	};


	soc {
		compatible = "simple-bus";
		#address-cells = <0x01>;
		#size-cells = <0x01>;
		ranges = <0x7e000000 0x00 0xfe000000 0x1800000 0x7c000000 0x00 0xfc000000 0x2000000 0x40000000 0x00 0xff800000 0x800000>;
		dma-ranges = <0xc0000000 0x00 0x00 0x40000000>;
		phandle = <0x45>;

		clocks{
			compatible = "brcm,bcm2835-aux";
    		#clock-cells = <1>;

			uart_clock: uartclk {
				compatible = "fixed-clock";
				#clock-cells = <1>;
				clock-frequency = "250000000"; // Frecuencia del reloj en Hz 250000000

				// Propiedades específicas del UART1
				uart1_clk: clock@0x7e101000 {
					compatible = "brcm,bcm2835-uart-clock";
					reg = <0x7e101000 0x2000>; // Inserta el índice del registro de configuración del reloj del UART1
					clocks = <&uart_clock>;
					clock-output-names = "uart1";
				};
			};
		};


		uart1: serial@7e215000 {
			#address-cells = <1>;
            #size-cells = <2>;
			
			compatible = "brcm,bcm2835-aux-uart"; // indica el controlador o driver compatible con el dispositivo, en este caso del uart.
			reg = <0x7e215000 0x68>; // rango de direcciones disponibles, en este caso son las direcciones usadas para el uart1.
			interrupts = <0x0 0x5d 0x4>; //La sintaxis utilizada es <interrupt-controller-id> <interrupt-id> <interrupt-flag>
				
				/**
				<interrupt-controller-id>: 0x0. Esto indica el identificador del controlador de interrupciones al que está conectado el UART.
				<interrupt-id>: 0x5d. Este es el número de identificación de la interrupción específica del UART.
				<interrupt-flag>: 0x4. Indica el tipo de interrupción o su configuración adicional.
				*/
			// clocks = <&clocks>;
			// clocks = <&uart1_clk BCM2835_UART_CLOCK>;
			// clock-names = "uartclk";

			status = "okay";
			pinctrl-names = "default";
			pinctrl-0 = <0x15>;
			skip-init;
			phandle = <0x31>;

			regmap = <&uart1_regmap>;


            /*uart1_regmap: uart1-regmap {
				compatible = "brcm,bcm2835-aux-uart";
                #address-cells = <1>;
                #size-cells = <1>;
				interrupt-controller;
				#interrupt-cells = <1>;

                reg-names = "aux_mu_io", "aux_mu_ier", "aux_mu_iir", "aux_mu_lcr", "aux_mu_mcr",
                            "aux_mu_lsr", "aux_mu_msr", "aux_mu_scratch", "aux_mu_cntl",
                            "aux_mu_stat", "aux_mu_baud";
                reg = <0x40 0x00 0x00>,
                      <0x44 0x00 0x00>,
                      <0x48 0x00 0x00>,
                      <0x4C 0x00 0x00>,
                      <0x50 0x00 0x00>,
                      <0x54 0x00 0x00>,
                      <0x58 0x00 0x00>,
                      <0x5C 0x00 0x00>,
                      <0x60 0x00 0x00>,
                      <0x64 0x00 0x00>,
                      <0x68 0x00 0x00>;
            };*/

			uart1_regmap: uart1-regmap {
				compatible = "brcm,bcm2835-aux-uart";
				#address-cells = <1>;
				#size-cells = <1>;
				interrupt-controller;
				#interrupt-cells = <1>;

				aux_enables: aux-enables@04 {
					reg = <0x04 0x20>;
				};

				aux_mu_io: reg-aux-mu-io@40 {
					reg = <0x40 0x20>;
				};

				aux_mu_ier: reg-aux-mu-ier@44 {
					reg = <0x44 0x20>;
				};

				aux_mu_iir: reg-aux-mu-iir@48 {
					reg = <0x48 0x20>;
				};

				aux_mu_lcr: reg-aux-mu-lcr@4C {
					reg = <0x4C 0x20>;
				};

				aux_mu_mcr: reg-aux-mu-mcr@50 {
					reg = <0x50 0x20>;
				};

				aux_mu_lsr: reg-aux-mu-lsr@54 {
					reg = <0x54 0x20>;
				};

				aux_mu_msr: reg-aux-mu-msr@58 {
					reg = <0x58 0x20>;
				};

				aux_mu_scratch: reg-aux-mu-scratch@5C {
					reg = <0x5C 0x20>;
				};

				aux_mu_cntl: reg-aux-mu-cntl@60 {
					reg = <0x60 0x20>;
				};

				aux_mu_stat: reg-aux-mu-stat@64 {
					reg = <0x64 0x20>;
				};

				aux_mu_baud: reg-aux-mu-baud@68 {
					reg = <0x68 0x20>;
				};
			};
		};


		serial@7e201000 {
			compatible = "arm,pl011\0arm,primecell";
			reg = <0x7e201000 0x200>;
			interrupts = <0x00 0x79 0x04>;
			clocks = <0x07 0x13 0x07 0x14>;
			clock-names = "uartclk\0apb_pclk";
			arm,primecell-periphid = <0x241011>;
			pinctrl-names = "default";
			pinctrl-0 = <0x08 0x09>;
			uart-has-rtscts;
			status = "okay";
			cts-event-workaround;
			skip-init;
			phandle = <0x30>;

		};




		/*

		Borro puertos serie asignados a las direcciones de memoria de los uart3/4/5.
		serial@7e201400 {
			compatible = "arm,pl011\0arm,primecell";
			reg = <0x7e201400 0x200>;
			interrupts = <0x00 0x79 0x04>;
			clocks = <0x07 0x13 0x07 0x14>;
			clock-names = "uartclk\0apb_pclk";
			arm,primecell-periphid = <0x241011>;
			status = "disabled";
			phandle = <0xb7>;
		};

		serial@7e201600 {
			compatible = "arm,pl011\0arm,primecell";
			reg = <0x7e201600 0x200>;
			interrupts = <0x00 0x79 0x04>;
			clocks = <0x07 0x13 0x07 0x14>;
			clock-names = "uartclk\0apb_pclk";
			arm,primecell-periphid = <0x241011>;
			status = "disabled";
			phandle = <0xb8>;
		};

		serial@7e201800 {
			compatible = "arm,pl011\0arm,primecell";
			reg = <0x7e201800 0x200>;
			interrupts = <0x00 0x79 0x04>;
			clocks = <0x07 0x13 0x07 0x14>;
			clock-names = "uartclk\0apb_pclk";
			arm,primecell-periphid = <0x241011>;
			status = "disabled";
			phandle = <0xb9>;
		};

		serial@7e201a00 {
			compatible = "arm,pl011\0arm,primecell";
			reg = <0x7e201a00 0x200>;
			interrupts = <0x00 0x79 0x04>;
			clocks = <0x07 0x13 0x07 0x14>;
			clock-names = "uartclk\0apb_pclk";
			arm,primecell-periphid = <0x241011>;
			status = "disabled";
			phandle = <0xba>;
		};
		*/

	};




	__overrides__ {
		// uart0 = "\0\0\00status";
		uart1 = "\0\0\01status";
		// act_led_gpio = "\0\0\0=gpios:4";
		// act_led_activelow = "\0\0\0=gpios:8";
		// act_led_trigger = "\0\0\0=linux,default-trigger";
		// pwr_led_gpio = "\0\0\0>gpios:4";
		// pwr_led_activelow = "\0\0\0>gpios:8";
		// pwr_led_trigger = "\0\0\0>linux,default-trigger";
	};


	__symbols__ {
		rmem = "/reserved-memory";
		// cma = "/reserved-memory/linux,cma";
		// blconfig = "/reserved-memory/nvram@0";
		soc = "/soc";
		// uart0_gpio14 = "/soc/gpio@7e200000/uart0_gpio14";
		// uart0_ctsrts_gpio16 = "/soc/gpio@7e200000/uart0_ctsrts_gpio16";
		// uart0_ctsrts_gpio30 = "/soc/gpio@7e200000/uart0_ctsrts_gpio30";
		// uart0_gpio32 = "/soc/gpio@7e200000/uart0_gpio32";
		// uart0_gpio36 = "/soc/gpio@7e200000/uart0_gpio36";
		// uart0_ctsrts_gpio38 = "/soc/gpio@7e200000/uart0_ctsrts_gpio38";
		// uart1_gpio14 = "/soc/gpio@7e200000/uart1_gpio14";
		// uart1_ctsrts_gpio16 = "/soc/gpio@7e200000/uart1_ctsrts_gpio16";
		// uart1_gpio32 = "/soc/gpio@7e200000/uart1_gpio32";
		// uart1_ctsrts_gpio30 = "/soc/gpio@7e200000/uart1_ctsrts_gpio30";
		// uart1_gpio40 = "/soc/gpio@7e200000/uart1_gpio40";
		// uart1_ctsrts_gpio42 = "/soc/gpio@7e200000/uart1_ctsrts_gpio42";
		// uart2_ctsrts_gpio2 = "/soc/gpio@7e200000/uart2_ctsrts_gpio2";
		// uart3_gpio4 = "/soc/gpio@7e200000/uart3_gpio4";
		// uart3_ctsrts_gpio6 = "/soc/gpio@7e200000/uart3_ctsrts_gpio6";
		// uart4_gpio8 = "/soc/gpio@7e200000/uart4_gpio8";
		// uart4_ctsrts_gpio10 = "/soc/gpio@7e200000/uart4_ctsrts_gpio10";
		// uart5_gpio12 = "/soc/gpio@7e200000/uart5_gpio12";
		// uart5_ctsrts_gpio14 = "/soc/gpio@7e200000/uart5_ctsrts_gpio14";
		// uart0_pins = "/soc/gpio@7e200000/uart0_pins";
		// uart1_pins = "/soc/gpio@7e200000/uart1_pins";
		// uart2_pins = "/soc/gpio@7e200000/uart2_pins";
		// uart3_pins = "/soc/gpio@7e200000/uart3_pins";
		// uart4_pins = "/soc/gpio@7e200000/uart4_pins";
		// uart5_pins = "/soc/gpio@7e200000/uart5_pins";
		// uart0 = "/soc/serial@7e201000";
		// aux = "/soc/aux@7e215000";
		uart1 = "/soc/serial@7e215000";
		// random = "/soc/rng@7e104000";
		// uart2 = "/soc/serial@7e201400";
		// uart3 = "/soc/serial@7e201600";
		// uart4 = "/soc/serial@7e201800";
		// uart5 = "/soc/serial@7e201a00";
	};
};


/*
&uart1 {
	status = "okay";
	registers = <AUX_MU_IO_REG AUX_MU_IER_REG AUX_MU_IIR_REG AUX_MU_LCR_REG AUX_MU_MCR_REG
				AUX_MU_LSR_REG AUX_MU_MSR_REG AUX_MU_SCRATCH AUX_MU_CNTL_REG
				AUX_MU_STAT_REG AUX_MU_BAUD_REG>;
};



		gpio@7e200000 {
			compatible = "brcm,bcm2711-gpio";
			reg = <0x7e200000 0xb4>;
			interrupts = <0x00 0x71 0x04 0x00 0x72 0x04>;
			gpio-controller;
			#gpio-cells = <0x02>;
			interrupt-controller;
			#interrupt-cells = <0x02>;
			pinctrl-names = "default";
			gpio-line-names = "\0TXD1\0RXD1\0GPIO16\0GPIO17\0GPIO18\0GPIO19\0GPIO20\0GPIO21\0GPIO22\0GPIO23\0GPIO24\0GPIO25\0GPIO26\0GPIO27\0RGMII_MDIO\0RGMIO_MDC\0CTS0\0RTS0\0TXD0\0RXD0\0SD1_CLK\0SD1_CMD\0SD1_DATA0\0SD1_DATA1\0SD1_DATA2\0SD1_DATA3\0PWM0_MISO\0PWM1_MOSI\0STATUS_LED_G_CLK\0SPIFLASH_CE_N\0SDA0\0SCL0\0RGMII_RXCLK\0RGMII_RXCTL\0RGMII_RXD0\0RGMII_RXD1\0RGMII_RXD2\0RGMII_RXD3\0RGMII_TXCLK\0RGMII_TXCTL\0RGMII_TXD0\0RGMII_TXD1\0RGMII_TXD2\0RGMII_TXD3";
			phandle = <0x0f>;

			uart0_gpio14 {
				brcm,pins = <0x0e 0x0f>;
				brcm,function = <0x04>;
				phandle = <0x5c>;
			};

			uart0_ctsrts_gpio16 {
				brcm,pins = <0x10 0x11>;
				brcm,function = <0x07>;
				phandle = <0x5d>;
			};

			uart0_ctsrts_gpio30 {
				brcm,pins = <0x1e 0x1f>;
				brcm,function = <0x07>;
				brcm,pull = <0x02 0x00>;
				phandle = <0x5e>;
			};

			uart0_gpio32 {
				brcm,pins = <0x20 0x21>;
				brcm,function = <0x07>;
				brcm,pull = <0x00 0x02>;
				phandle = <0x5f>;
			};

			uart0_gpio36 {
				brcm,pins = <0x24 0x25>;
				brcm,function = <0x06>;
				phandle = <0x60>;
			};

			uart0_ctsrts_gpio38 {
				brcm,pins = <0x26 0x27>;
				brcm,function = <0x06>;
				phandle = <0x61>;
			};

			uart1_gpio14 {
				brcm,pins = <0x0e 0x0f>;
				brcm,function = <0x02>;
				phandle = <0x62>;
			};

			uart1_ctsrts_gpio16 {
				brcm,pins = <0x10 0x11>;
				brcm,function = <0x02>;
				phandle = <0x63>;
			};

			uart1_gpio32 {
				brcm,pins = <0x20 0x21>;
				brcm,function = <0x02>;
				phandle = <0x64>;
			};

			uart1_ctsrts_gpio30 {
				brcm,pins = <0x1e 0x1f>;
				brcm,function = <0x02>;
				phandle = <0x65>;
			};

			uart1_gpio40 {
				brcm,pins = <0x28 0x29>;
				brcm,function = <0x02>;
				phandle = <0x66>;
			};

			uart1_ctsrts_gpio42 {
				brcm,pins = <0x2a 0x2b>;
				brcm,function = <0x02>;
				phandle = <0x67>;
			};


			uart0_pins {
				brcm,pins = <0x20 0x21>;
				brcm,function = <0x07>;
				brcm,pull = <0x00 0x02>;
				phandle = <0x08>;
			};

			uart1_pins {
				brcm,pins;
				brcm,function;
				brcm,pull;
				phandle = <0x15>;
			};

			/**
			
			He definido únicamente para los puertos uart0 y uart1, los demas los he borrado que se pueden obtener del otro .dts
			
		locks BCM2835_CLOCK_UART>;
			// clock-names = 	*/
